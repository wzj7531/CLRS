\documentclass[a4paper,11pt]{article}
\usepackage{geometry}
\geometry{left=2cm,top=2cm,right=2cm}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceiling}[1]{\lceil #1 \rceil}
\usepackage{clrscode3e}
\usepackage{ctex}
\usepackage{amsmath}
\usepackage{forest}
\usepackage{mathtools}

\begin{document}
\section*{4.1 最大子数组问题}
\begin{codebox}
\Procname{$\proc{FIND-MAX-CROSSING-SUBARRAY}(A,low,mid,high)$}
\li $\id{left-sum} \gets -\infty$
\li $\id{sum} \gets 0$
\li \For $i \gets \id{mid} \Downto low$
\li 	\Do
			$\id{sum} \gets \id{sum} + A[i]$
\li		\If $\id{sum} > \id{left-sum}$
\li				\Then
					$\id{left-sum} \gets \id{sum}$
\li				$\id{max-left} \gets i$					
					\End
			\End
\li	$\id{right-sum} \gets -\infty$
\li $\id{sum} \gets 0$
\li \For $j \gets \id{mid} + 1 \To high$
\li		\Do
			$\id{sum} \gets \id{sum} + A[j]$
\li		\If $\id{sum} > \id{right-sum}$
\li			\Then
					$\id{right-sum} \gets \id{sum}$
\li				$\id{max-right} \gets j$	
				\End
			\End
			\li \Return $(\id{max-left},\id{max-right},\id{left-sum}+\id{right-sum})$
\end{codebox}

\begin{codebox}
	\Procname{$\proc{FIND-MAXIMUM-SUBARRAY}(A,low,high)$}
	\li	\If $\id{high} \isequal \id{low}$
	\li		\Then 
					\Return $(\id{low},\id{high},A[low])$
	\li		\Else 
					$\id{mid} \gets \floor{(\id{low}+\id{high})/2}$
	\li			$(\id{left-low},\id{left-high},\id{left-sum}) \gets \proc{FIND-MAXIMUM-SUBARRAY}(A,low,mid)$
	\li			$(\id{right-low},\id{right-high},\id{right-sum}) \gets \proc{FIND-MAXUMUM-SUBARRAY}(A,mid+1,high)$
	\li			$(\id{cross-low},\id{cross-high},\id{cross-sum}) \gets \proc{FIND-MAXIMUM-SUBARRAY}(A,low,mid,high)$
	\li			\If $\id{left-sum} \geq \id{right-sum}$ and $\id{left-sum} \geq \id{cross-sum}$
	\li				\Then \Return $(\id{left-low},\id{left-high},\id{left-sum})$
	\li				\ElseIf $\id{right-sum} \geq \id{left-sum}$ and $\id{right-sum} \geq \id{cross-sum}$
	\li				\Then \Return $(\id{right-low},\id{right-high},\id{right-sum})$
	\li				\ElseNoIf \Return $(\id{corss-low},\id{cross-high},\id{cross-sum})$
						\End
				\End
\end{codebox}
\section*{分治算法的分析}
首先，第1行花费常量时间，对于$n \gets 1$的基本情况，也很简单：第2行花费常量时间，因此，
\[
	T(1) = \Theta(1)
\]
当$n>1$时为递归情况。第1行和第3行花费常量时间，第4行和第5行求解的子问题均为$n/2$个元素的子数组(假定原问题规模为2的幂，保证了$n/2$为整数)，因此每个子问题的求解时间为$T(n/2)$。因为需要求解两个子问题，因此第4行和第5行给总运行时间增加了$2T(n/2)$。又因为第6行花费$\Theta(n)$时间，第7-11行仅花费$\Theta(1)$时间。所以对于递归情况，我们有：
\[
	T(n)=
	\begin{cases}
		\Theta(1) & \text{若 $n=1$}\\
		2T(n/2) + \Theta(n) & \text{若$n>1$}
	\end{cases}
\]
上面递归式的解为$T(n)=\Theta(nlgn)$。
\section*{练习}
\paragraph*{4.1-1}
当A的所有元素均为负数时，$\proc{Find-Maximum-SubArray}$返回什么？\\
返回其中最大的那个负数及其在数组中的位置。
\paragraph*{4.1-2}
对最大子数组问题，编写暴力求解方法的伪代码，其运行时间应该为$\Theta(n^2)$
\begin{codebox}
	\Procname{$\proc{Find-Maximum-SubArray-Violence}(A)$}
	\li $\id{max-sum} \gets A[0]$
	\li $\id{left} \gets 0$
	\li $\id{right} \gets 0$
	\li $\id{temp-sum} \gets 0$
	\li \For $i \gets 1 \To \attrib{A}{length}-1$
	\li		\Do $\id{temp-sum}\gets A[i]$
	\li		\For $j \gets i+1 \To \attrib{A}{length}$
	\li			\Do $\id{temp-sum} = \id{temp-sum} + A[j]$
	\li			\If $\id{temp-sum} > \id{max-sum}$
	\li				\Then $\id{max-sum}=\id{temp-sum}$
	\li				$\id{left} = i$
	\li				$\id{right} = j$
						\End
					\End
				\End
	\li \Return $(\id{left},\id{right},\id{max-sum})$
\end{codebox}
\paragraph*{4.1-4}
假定修改最大子数组问题的定义，允许结果为空子数组，其和为0。你应该如何修改现有算法，使它们能允许空子数组为最终结果？\\
只需将$\proc{Find-Max-Crossing-SubArray}$修改如下(注意，这里假定数组下标从1开始)：
\begin{codebox} 
  \Procname{$\proc{FIND-MAX-CROSSING-SUBARRAY}(A,low,mid,high)$}
  \li $\id{left-sum} \gets 0$
  \li $\id{sum} \gets 0$
  \li \For $i \gets \id{mid} \Downto low$
  \li   \Do
        $\id{sum} \gets \id{sum} + A[i]$ 
  \li   \If $\id{sum} > \id{left-sum}$
  \li       \Then 
            $\id{left-sum} \gets \id{sum}$
  \li       $\id{max-left} \gets i$
            \End
        \End
  \li $\id{right-sum} \gets 0$
  \li $\id{sum} \gets 0$
  \li \For $j \gets \id{mid} + 1 \To high$
  \li   \Do 
        $\id{sum} \gets \id{sum} + A[j]$
  \li   \If $\id{sum} > \id{right-sum}$
  \li     \Then
            $\id{right-sum} \gets \id{sum}$ 
  \li       $\id{max-right} \gets j$
          \End
        \End
  \li \Return $(\id{max-left},\id{max-right},\id{left-sum}+\id{right-sum})$
  \end{codebox}
\paragraph*{4.1-5}
使用如下思想为最大子数组问题设计一个非递归的、线性时间的算法。从数组的左边界开始，由左至右处理，记录到目前为止已经处理过的最大子数组。若已知$A[1 \dots j]$的最大子数组，基于如下性质讲解扩展为$A[1 \dots j+1]$的最大子数组:$A[1 \dots j+1]$的最大子数组要么是$A[1 \dots j]$的最大子数组，要么是某个子数组$A[i \dots j+1](1 \leq i \leq j+1)$。在已知$A[1 \dots j]$的最大子数组的情况下，可以在线性时间内找出形如$A[i \dots j+1]$的最大子数组。
\begin{codebox}
	\Procname{$\proc{Find-Maximum-Subarray-Linear}(A)$}
	\li	$\id{left} \gets 0$
	\li $\id{right} \gets 0$
	\li $\id{temp-sum} \gets A[0]$
	\li $\id{max-sum} \gets \id{temp-sum}$
	\li \For $j \gets 1 \To \attrib{A}{length}$
	\li		\Do $\id{temp-sum} \gets \id{temp-sum} + a[j]$
	\li		\If $\id{max-sum} < \id{temp-sum}$
	\li			\Then $\id{right \gets j}$
	\li			$\id{max-sum} \gets \id{temp-sum}$
	\li			\Else
	\li				\If $A[j] > \id{temp-sum}$
	\li					\Then $\id{left} \gets j$
	\li					$\id{right} \gets j$
	\li					$\id{temp-sum} \gets A[j]$
	\li					$\id{max-sum} \gets \id{temp-sum}$
							\End
					\End
				\End
	\li \Return $(\id{left},\id{right},\id{max-sum})$
\end{codebox}
\section*{4.2 矩阵乘法的Strassen算法}
\begin{codebox}
	\Procname{$\proc{SQUARE-MATRIX-MULTIPLY}(A,B)$}
	\li $\id{n} \gets \attrib{A}{rows}$
	\li let C be a new $n \times n$ matrix
	\li \For $i \gets 1 \To n$
	\li		\Do
				\For $j \gets 1 \To n$
	\li			\Do $c_{ij} \gets 0$
	\li			\For $k \gets 1 \To n$
	\li				\Do	$c_{ij} \gets c_{ij} + a_{ik} \cdot b_{kj}$
						\End
					\End
				\End
	\li	\Return $C$
\end{codebox}
上面过程中，由于三重for循环的每一重都恰好执行n步，而第7行每次执行都花费常量时间，因此花费$\Theta(n^3)$时间。
\paragraph*{矩阵乘法的一个简单的分治算法}
\begin{codebox}
	\Procname{$\proc{SQUARE-MATRIX-MULTIPLY-RECURSIVE}(A,B)$}
	\li $n \gets \attrib{A}{rows}$
	\li Let $C$ be a new $n \times n$ matrix
	\li \If $n \isequal 1$
	\li		\Then $c_{11} \gets a_{11} \cdot b_{11}$
	\li		\Else $patition\ A,\ B,\ and \ C$
	\li			$C_{11} \gets \proc{SQUARE-MATRIX-MULTIPLY-RECURSIVE}(A_{11},B_{11})$\\
	\>\>$+\proc{SQUARE-MATRIX-MULTIPLY-RECURSIVE}(A_{12},B_{21})$
	\li			$C_{12} \gets \proc{SQUARE-MATRIX-MULTIPLY-RECURSIVE}(A_{11},B_{12})$\\
	\>\>$+\proc{SQUARE-MATRIX-MULTIPLY-RECURSIVE}(A_{12},B_{22})$
	\li			$C_{21} \gets	\proc{SQUARE-MATRIX-MULTIPLY-RECURSIVE}(A_{21},B_{11})$\\
	\>\>$+\proc{SQUARE-MATRIX-MULTIPLY-RECURSIVE}(A_{22},B_{21})$
	\li			$C_{22} \gets \proc{SQUARE-MATRIX-MULTIPLY-RECURSIVE}(A_{21},B_{12})$\\
	\>\>$+\proc{SQUARE-MATRIX-MULTIPLY-RECURSIVE}(A_{22},B_{22})$
				\End
	\li	\Return $C$
\end{codebox}
注意，在具体的C实现中，不会真的把$A,B,C$矩阵分为12个新的子矩阵，我们可以计算下标来限定子矩阵的范围，例如，一对坐标表示子矩阵的起始位置，再用一个整数表示该子矩阵的行或者列数，就可以知道子矩阵的范围了，这就是上述伪代码隐藏的实现细节。另外矩阵C在程序开始时初始化为具有A $\times$ B大小的矩阵，每一次递归到基本情况时，就在C上进行计算，待8次递归调用完成后，矩阵C就是A $\times$ B的结果了。\\
现在来分析一下算法的运行时间。由于使用下标计算对$A,B,C$进行子矩阵分解，所以第5行只需$\Theta(1)$的时间，注意，使用下标计算而非通过复制元素(如果这样做则分解矩阵则需要$\Theta(n^2)$的时间)来分解矩阵对总渐进运行时间并无影响。令$T(n)$表示此过程的运行时间。对$n=1$的基本情况，只需要进行一次标量乘法(第4行)，因此
\[
	T(n) = \Theta(1)
\]
当$n>1$时是递归情况，第5行花费$\Theta(1)$的时间，第6-9行共8次递归调用，由于每次递归调用完成两个$n/2 \times n/2$矩阵乘法，因此花费时间为$T(n/2)$，8次递归调用总时间为$8T(n/2)$。还需要计算6-9行的4次矩阵加法。每个矩阵包含$n^2/4$个元素，因此每次矩阵加法花费$\Theta(n^2)$时间。由于矩阵加法的的次数是常数，第6-9行进行矩阵假发的总时间为$\Theta(n^2)$(这里仍然使用下标计算的方法讲矩阵加法的结果放置于C的正确位置，由此带来的额外开销为每个元素$\Theta(1)$)。因此，递归情况的总时间为分解时间、递归调用时间以及矩阵加法时间之和：
\[
	T(n) = \Theta(1)+8\Theta(n/2)+\Theta(n^2)=8T(n/2)+\Theta(n^2)
\]
注意，如果通过复制元素来实现矩阵的分解，额外开销为$\Theta(n^2)$，递归式不会发生改变，只是总运行时间将会提高常数倍。综上，
\[
	T(n) = 
	\begin{cases}
	\Theta(1) & \text{若n=1}\\
	8\Theta(n/2)+\Theta(n^2) & \text{若n>1}
	\end{cases}
\]
利用后面学习的主定理，得到的解为$T(n)=\Theta(n^3)$，因此简单的分治算法并不优于暴力算法。注意，因子8决定了递归树中每个节点有几个子节点，进而决定了树的每一层为总和贡献了多少项。如果省略因子8，递归树就变为线性结构，而不是“茂盛的”了，树的每一层只为总和贡献了一项。
\section*{Strassen方法}
Strassen方法的核心思想是用常数次的矩阵加法的代价减少一次矩阵乘法。其递归式如下所示:
\[
	T(n) = 
	\begin{cases}
		\Theta(1) & \text{若n=1} \\
		7\Theta(n/2) + \Theta(n^2) &\text{若n>1}
	\end{cases}
\]
再次利用后面的主定理，$T(n)=\Theta(n^{lg7})$。
\section*{练习}
\paragraph*{4.2-1}
使用Strassen算法计算如下矩阵乘法:
\[
	\begin{gathered}
		\begin{bmatrix}
			1 & 3\\
			7 & 5
		\end{bmatrix}
		\quad
		\begin{bmatrix}
			6 & 8\\
			4 & 2
		\end{bmatrix}
	\end{gathered}
\]
给出计算过程。\\
我们从步骤2开始计算$S_1,S_2,\cdots,S_{10}$:
\[
	\begin{align}
		%下面一定要空一行，否则S_1等式就不会出现

		S_1 = B_{12}-B_{22}=
		\begin{bmatrix}
			8
		\end{bmatrix}
		-
		\begin{bmatrix}
			2
		\end{bmatrix}
		=
		\begin{bmatrix}
			6
		\end{bmatrix} \\

		S_2 = A_{11}+A_{12}=
  	\begin{bmatrix}
 		1
  	\end{bmatrix}
		+
		\begin{bmatrix}
		3
		\end{bmatrix}
		=
		\begin{bmatrix}
		4
		\end{bmatrix} \\

		S_3 = A_{21}+A_{22}=
  	\begin{bmatrix}
 		7
  	\end{bmatrix}
		+
		\begin{bmatrix}
		5
		\end{bmatrix}
		=
		\begin{bmatrix}
		12
		\end{bmatrix} \\

		S_4 = B_{21}+B_{11}=
  	\begin{bmatrix}
 		4
  	\end{bmatrix}
		-
		\begin{bmatrix}
		6
		\end{bmatrix}
		=
		\begin{bmatrix}
		-2
		\end{bmatrix} \\

		S_5 = A_{11}+A_{22}=
  	\begin{bmatrix}
 		1
  	\end{bmatrix}
		+
		\begin{bmatrix}
		5
		\end{bmatrix}
		=
		\begin{bmatrix}
		6
		\end{bmatrix} \\

		S_6 = B_{11}+B_{22}=
  	\begin{bmatrix}
 		6
  	\end{bmatrix}
		+
		\begin{bmatrix}
		2
		\end{bmatrix}
		=
		\begin{bmatrix}
		8
		\end{bmatrix} \\

	  S_7 = A_{12}-A_{22}=
  	\begin{bmatrix}
 		3
  	\end{bmatrix}
		-
		\begin{bmatrix}
		5
		\end{bmatrix}
		=
		\begin{bmatrix}
		-2
		\end{bmatrix} \\

	  S_8 = B_{21}+B_{22}=
  	\begin{bmatrix}
 		4
  	\end{bmatrix}
		+
		\begin{bmatrix}
		2
		\end{bmatrix}
		=
		\begin{bmatrix}
		6
		\end{bmatrix} \\

	  S_9 = A_{11}-A_{21}=
  	\begin{bmatrix}
 		1
  	\end{bmatrix}
		-
		\begin{bmatrix}
		7
		\end{bmatrix}
		=
		\begin{bmatrix}
		-6
		\end{bmatrix} \\

		S_{10} = B_{11}+B_{12}=
  	\begin{bmatrix}
 		6
  	\end{bmatrix}
		+
		\begin{bmatrix}
		8
		\end{bmatrix}
		=
		\begin{bmatrix}
		14
		\end{bmatrix}
	\end{align}
\]
然后进行步骤3的计算:

\end{document}
